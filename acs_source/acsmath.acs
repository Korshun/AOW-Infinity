#libdefine INT_MAX 0x7fffffff
#libdefine INT_MIN 0x80000000
#libdefine SHORT_MAX 32767
#libdefine SHORT_MIN -32768

#libdefine PI 3.1415926535897932384626433832795
#libdefine SQRT_2 1.41421356237
#libdefine MATH_E 2.7182818284590452353602874713526624977572470937
#libdefine LOG2_E 1.44269504089
#libdefine LOG2_10 3.32192809489

// Generic functions.

// num min(num a, num b)
function int min(int a, int b)
{
	if (a < b)
		return a;
	return b;
}

// num max(num a, num b)
function int max(int a, int b)
{
	if (a > b)
		return a;
	return b;
}

// num clamp(num x, num a, num b)
function int clamp(int x, int a, int b)
{
	if (x > b)
		return b;
	if (x < a)
		return a;
	return x;
}	

// int sgn(num x)
function int sgn(int x)
{
	if (x > 0)
		return 1;
	if (x < 0)
		return -1;
	return 0;
}

// num abs(num x)
function int abs(int x)
{
	if (x > 0)
		return x;
	return -x;
}

// From commonFuncs.h by Ijon Tichy.
// num middle(num a, num b, num c)
function int middle(int x, int y, int z)
{
    if ((x < z) && (y < z)) { return max(x, y); }
    return max(min(x, y), z);
}

// int cmp(num a, num b)
function int cmp(int a, int b)
{
	if (a > b)
		return 1;
	if (a < b)
		return -1;
	return 0;
}

// num mod(num a, num b)
function int mod(int a, int b)
{
	int result = a % b;
	result += (result < 0) * (b - result);
	return result;
}

// any cond(bool x, any whentrue, any shenfalse)
function int cond(bool x, int whentrue, int whenfalse)
{
	if (x)
		return whentrue;
	return whenfalse;
}


// Rounding.

// fixed trunc(fixed x)
function int trunc(int x)
{
	return (x & 0xffff0000) + ((x < 0)<<16);
}

// fixed floor(fixed x)
function int floor(int x)
{
	return x & 0xffff0000;
}

// fixed ceil(fixed x)
function int ceil(int x)
{
	return ((x - 1) & 0xffff0000) + 1.0;
}

// fixed round(fixed x)
function int round(int x)
{
	return (x + 0.5) & 0xffff0000;
}

// int itrunc(fixed x)
function int itrunc(int x)
{
	return (x>>16) + (x < 0);
}

// int ifloor(fixed x)
function int ifloor(int x)
{
	return x>>16;
}

// int iceil(fixed x)
function int iceil(int x)
{
	return (x - 1 >> 16) + 1;
}

// int iround(fixed x)
function int iround(int x)
{
	return x + 0.5 >> 16;
}

// By Monsterovich

// fixed itof(int x)
function int itof(int x)
{
	return x << 16;
}


// Numerical algorithms.

// int ipow(int x, int y)
function int ipow(int x, int y)
{
    int n = 1;
    while (y-- > 0)
		n *= x;
    return n;
}

// fixed fpow(fixed x, int y)
function int fpow(int x, int y)
{
	int n = 1.0;
	if (y > 0)
	{
		while (y-- > 0)
			n = FixedMul(n, x);
		return n;
	}
	
	while (y++ < 0)
		n = FixedDiv(n, x);
	return n;
}

// fixed lerp(fixed a, fixed b, fixed alpha)
function int lerp(int a, int b, int alpha)
{
	return FixedMul(a, 1.0 - alpha) + FixedMul(b, alpha);
}

// From ZDoom wiki.
// int zan_Sqrt(int number)
function int zan_Sqrt(int number)
{
	if(number <= 3) { return number > 0; }

	int oldAns = number >> 1,                     // initial guess
	    newAns = (oldAns + number / oldAns) >> 1; // first iteration

	// main iterative method
	while(newAns < oldAns)
	{
		oldAns = newAns;
		newAns = (oldAns + number / oldAns) >> 1;
	}

	return oldAns;
}

#libdefine FIXEDSQRT_EPS 0x1e6

// By Monsterovich.
// fixed zan_FixedSqrt(fixed number)
function int zan_FixedSqrt(int a)
{
	int x = 0;
	int y = a;
	int val = 0;

	// x & y shouldn't be zero
	while ((x != 0 || y != 0) && y - x > FIXEDSQRT_EPS) 
	{
		val = FixedDiv(x + y, 2.0);

        if (FixedMul(val, val) >= a)
			y = val; 
		else 
			x = val;
	}

	return val;
}

// From commonFuncs.h by Ijon Tichy.
// num gcf(num a, num b)
function int gcf(int a, int b)
{
    int c;
    while (1)
    {
        if (b == 0) { return a; }
        c = a % b;
        a = b;
        b = c;
    }
    
    return -1;
}

// By TechnoDoomed1
// fixed IntDiv(int a, int b)
function int IntDiv (int a, int b) {
    int quotient = 0, current_fraction = 1.0;

    // Only works when the ratio is less than 32767 = 2^15 - 1.
    // Otherwise return 0.

    if ((abs(a) / abs(b)) > 32767) {
        return 0;
    }

    // Performs the same algorithm as hand division, but working with powers of 2 instead of 10.
    // This is done until we reach the maximum allowed precision, which is 1 (=2^-16 in fixed point).

    while (current_fraction > 1) {
        quotient += (a / b) * current_fraction;
        a = (a % b) * 2;
        current_fraction /= 2;
    }

    return quotient;
}

// num npo2(num x)
function int npo2(int v)
{
	v--;
	v |= v >> 1;
	v |= v >> 2;
	v |= v >> 4;
	v |= v >> 8;
	v |= v >> 16;
	v++;
	return v;
}

// any, any swap(any a, any b)
function void swap(int a, int b)
{
	r1 = b;
	r2 = a;
}


// By Monsterovich

// angle AngleDistCCW(angle a, angle b)
function int AngleDistCCW (int a, int b)
{
	return abs(a - b);
}

// angle AngleDistCW(angle a, angle b)
function int AngleDistCW (int a, int b)
{
	return 1.0 - AngleDistCCW(a, b);
}


// Logarithms.

// All logaritm functions written by TechnoDoomed1 unless stated otherwise

// fixed log2(fixed x)
function int log2 (int x) {
    // We calculate the integral and decimal parts of the bit logarithm of x.
    int integer_part = 0, decimal_part = 0;

    // The integral part is how many times we can divide by 2 until we reach a number in the range [1, 2).
    // If the number is on the range (0, 1) then we multiply by 2 until we reach a number in the range [1, 2).
    while (x < 1.0) {
        -- integer_part;
        x *= 2;
    }
    while (x >= 2.0) {
        ++ integer_part;
        x /= 2;
    }

    // Then, we square the number each time to get the next relevant byte, until we reach max precision allowed.
    // WHY? Because if 2^d = y, then (2^d)^2 = 2^(2d) = y^2, where d is the decimal part.
    //-----------------------------------------------------------------------------------------------------------------
    // Let's start with the fraction 1/2, and go downwards until we reach the max precision for a fixed-point number,
    // which is 1 (since it occupies the right side of the byte, it really represents 2^-16).

    int current_fraction = 0.5;

    while (current_fraction > 1) {
        x = FixedMul(x, x);
        if (x >= 2.0) {
            decimal_part += current_fraction;
            x /= 2;
        }

        current_fraction /= 2;
    }

    // We can finally return the number as the integral part (shifted 16 bytes to the left, to be on the corresponding
    // integral part of the fixed-point number) plus the decimal part, which is the sum of all the fractions of 2 that
    // correspond to the solution of 2^d = y.

    return ((integer_part << 16) + decimal_part);
}

// fixed ilog2(int x)
function int ilog2 (int x) {
    // We calculate the integral and decimal parts of the bit logarithm of x.
    int integer_part = 0, decimal_part = 0;

    // The integral part is how many times we can divide by 2 until we reach a number lower than 2.
    // We lose precision by not keeping the fractional part until that part fits perfectly in a fixed number variable.
    while (x >= 32768) {
        ++ integer_part;
        x /= 2;
    }

    x <<= 16;

    while (x >= 2.0) {
        ++ integer_part;
        x /= 2;
    }

    // Then, we square the number each time to get the next relevant byte, until we reach max precision allowed.
    // WHY? Because if 2^d = y, then (2^d)^2 = 2^(2d) = y^2, where d is the decimal part.
    //-----------------------------------------------------------------------------------------------------------------
    // Let's start with the fraction 1/2, and go downwards until we reach the max precision for a fixed-point number,
    // which is 1 (since it occupies the right side of the byte, it really represents 2^-16).

    int current_fraction = 0.5;

    while (current_fraction > 1) {
        x = FixedMul(x, x);
        if (x >= 2.0) {
            decimal_part += current_fraction;
            x /= 2;
        }

        current_fraction /= 2;
    }

    // We can finally return the number as the integral part (shifted 16 bytes to the left, to be on the corresponding
    // integral part of the fixed-point number) plus the decimal part, which is the sum of all the fractions of 2 that
    // correspond to the solution of 2^d = y.

    return ((integer_part << 16) + decimal_part);
}


// fixed ln(fixed x)
function int ln (int x) {
    // This calculates the natural logarithm of a number using the property that:   ln(x) = log_2(x) / log_2(e)
    // This is done because calculating the log_2 of a number is far easier, specially with fixed-point arithmetics. 

    return FixedDiv(log2(x), LOG2_E);
}

// By Korshun.
// fixed iln(int x)
function int iln (int x) {
	return FixedDiv(ilog2(x), LOG2_E);
}

// By Korshun.
// fixed log10(int x)
function int log10 (int x) {
	return FixedDiv(log2(x), LOG2_10);
}

// By Korshun.
// fixed ilog10(int x)
function int ilog10 (int x) {
	return FixedDiv(ilog2(x), LOG2_10);
}

// fixed logb(fixed x, fixed base)
function int logb (int x, int base) {
    // This calculates the logarithm in any base > 1.0, by using the property that:   log_b(x) = log_2(x) / log_2(b)
    // Otherwise, returns 0.

    if (base > 1.0)
        return FixedDiv(log2(x), log2(base));
   
    return 0;
}

// By Korshun.
// fixed ilogb(int x, fixed base)
function int ilogb (int x, int base) {
    // This calculates the logarithm in any base > 1.0, by using the property that:   log_b(x) = log_2(x) / log_2(b)
    // Otherwise, returns 0.

    if (base > 1.0)
        return FixedDiv(ilog2(x), log2(base));
   
    return 0;
}

// Trigonometry.

// fixed tan(angle x)
function int tan(int x)
{
	return FixedDiv(sin(x), cos(x));
}

// fixed cot(angle x)
function int cot(int x)
{
	return FixedDiv(cos(x), sin(x));
}

// fixed sec(angle x)
function int sec(int x)
{
	return FixedDiv(1.0, sin(x));
}

//fixed cosec(angle x)
function int cosec(int x)
{
	return FixedDiv(1.0, cos(x));
}

// fixed atan(fixed x)
function int atan(int x)
{
    return VectorAngle(1.0, x);
}

// fixed asin(fixed x)
function int asin(int x)
{
	return atan(FixedDiv(x, zan_FixedSqrt(1.0 - FixedMul(x, x))));
}

// fixed acos(fixed x)
function int acos(int x)
{
	return 2 * atan(zan_FixedSqrt(FixedDiv(1.0 - x, 1.0 + x)));
}

//angle acot(fixed x)
function int acot(int x)
{
 	return 0.25 - atan(x);
}

//angle asec(fixed x)
function int asec(int x)
{
	return acos(FixedDiv(1, x));
}

//angle acosec(fixed x)
function int acosec(int x)
{
	 return asin(FixedDiv(1, x));
}

// Vectors.

// fixed, fixed RotateVector(fixed x, fixed y, angle angle);
function void RotateVector(int x, int y, int angle)
{
	// Rotate around Z axis.
	int s = sin(-angle);
	int c = cos(-angle);
	r1 = FixedMul(x, c) - FixedMul(y, s);
	r2 = FixedMul(x, s) + FixedMul(y, c);
}	

// fixed, fixed RotatePoint(fixed x, fixed y, fixed originX, fixed originY, angle angle)
function void RotatePoint(int x, int y, int originX, int originY, int angle)
{
	x -= originX;
	y -= originY;
	RotateVector(x, y, angle);
	r1 += originX;
	r2 += originY;
}

// angle, angle VectorToAngles(fixed x, fixed y, fixed z)
function void VectorToAngles(int x, int y, int z)
{
	int xy = length2d(x, y);
		
	r1 = VectorAngle(x, y);
	r2 = VectorAngle(xy, z);
}

// From ZDoom wiki. Modified to work on coordinates instead of actors.
// fixed length3d(fixed x, fixed y, fixed z)
function int length3d(int x, int y, int z)
{
	 int len;

	 int ang = vectorangle(x,y);
	 if(((ang+0.125)%0.5) > 0.25) len = fixeddiv(y, sin(ang));
	 else len = fixeddiv(x, cos(ang));

	 ang = vectorangle(len, z);
	 if(((ang+0.125)%0.5) > 0.25) return fixeddiv(z, sin(ang));
	 return fixeddiv(len, cos(ang));
}

// The function above simplified for 2D.
// fixed length2d(fixed x, fixed y)
function int length2d(int x, int y)
{
	 int ang = vectorangle(x,y);
	 if(((ang+0.125)%0.5) > 0.25) return fixeddiv(y, sin(ang));
	 return fixeddiv(x, cos(ang));
}

// fixed length2d2(int x, int y)
function int length2d2(int x, int y)
{
	return FixedMul(x, x) + FixedMul(y, y);
}

// fixed length3d2(int x, int y, int z)
function int length3d2(int x, int y, int z)
{
	return FixedMul(x, x) + FixedMul(y, y) + FixedMul(z, z);
}

// fixed dot2(fixed x1, fixed y1, fixed x2, fixed y2)
function int dot2(int x1, int y1, int x2, int y2)
{
	return FixedMul(x1, x2) + FixedMul(y1, y2);
}

// fixed dot3(fixed x1, fixed y1, fixed z1, fixed x2, fixed y2, fixed z2)
function int dot3(int x1, int y1, int z1, int x2, int y2, int z2)
{
	return FixedMul(x1, x2) + FixedMul(y1, y2) + FixedMul(z1, z2);
}

// fixed, fixed normalize2d(fixed x, fixed y)
function void normalize2d(int x, int y)
{
	int l = length2d(x, y);
	r1 = FixedDiv(x, l);
	r2 = FixedDiv(y, l);
}

// fixed, fixed, fixed normalize3d(fixed x, fixed y, fixed z)
function void normalize3d(int x, int y, int z)
{
	int l = length3d(x, y, z);
	r1 = FixedDiv(x, l);
	r2 = FixedDiv(y, l);
	r3 = FixedDiv(z, l);
}
